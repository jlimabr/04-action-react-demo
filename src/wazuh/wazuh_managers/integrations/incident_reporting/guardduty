#!/var/ossec/framework/python/bin/python3

from importlib.util import spec_from_loader, module_from_spec
from importlib.machinery import SourceFileLoader 
import json
import datetime
from dateutil import tz
import requests
import os

spec = spec_from_loader("slack_issues", SourceFileLoader("slack_issues", "/var/ossec/integrations/incident_reporting/jira"))
slack_issues = module_from_spec(spec)
spec.loader.exec_module(slack_issues)

accounts_file = open('/var/ossec/integrations/incident_reporting/accounts.json', 'r')
accounts_data = json.loads(accounts_file.read())
accounts_file.close()

headers = { "Content-Type": "application/json" }
user = os.environ.get('jira_user').replace('\n', '')
api_key = os.environ.get('jira_api_key').replace('\n', '')

from_zone = tz.gettz('UTC')
to_zone = tz.gettz('Europe/Lisbon')

def parse(log):
        title = log['rule']['description']
        source = 'GuardDuty'
        siem_id = log['id']
        summary = log['data']['aws']['description']
        account_id = log['data']['aws']['accountId']
        village = accounts_data[account_id]['village']
        team = accounts_data[account_id]['team']
        account_name = accounts_data[account_id]['account_name']
        first_seen = datetime.datetime.strptime(log['data']['aws']['updatedAt'].split('.')[0]+'Z', '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=from_zone).astimezone(to_zone)
        first_detected = datetime.datetime.strptime(log['timestamp'].split('+')[0].split('.')[0], '%Y-%m-%dT%H:%M:%S').replace(tzinfo=from_zone).astimezone(to_zone)
        last_seen = datetime.datetime.strptime(log['data']['aws']['updatedAt'].split('.')[0]+'Z', '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=from_zone).astimezone(to_zone)

        guardduty_id = log['data']['aws']['id']
        region = log['data']['aws']['region']
        severity = log['data']['aws']['severity']
        alert_type = log['data']['aws']['type']
        pre_analysis = ''

        description = ''
        description += '*Summary:* ' + summary + '\n'
        description += '*Log Source:* ' + source + '\n'
        description += '*SIEM ID/s:* ' + siem_id + '\n\n'
        description += '*First seen:* ' + str(first_seen) + '\n'
        description += '*First detected:* ' + str(first_detected) + '\n'
        description += '*Last seen:* ' + str(last_seen) + '\n\n'
        description += '*AWS Region:* ' + region + '\n'
        description += '*AWS Account:* #' + account_id + ' | ' + account_name + '\n'
        description += '*AWS GuardDuty Finding ID/s:* ' + guardduty_id + '\n\n'

        # ssh brute force use case code
        if alert_type == 'UnauthorizedAccess:EC2/SSHBruteForce':

                # define threat actor, target, category, subcategory, impact and urgency
                threat_actor = log['data']['aws']['service']['action']['networkConnectionAction']['remoteIpDetails']['ipAddressV4']
                target = log['data']['aws']['resource']['instanceDetails']['instanceId']

                category = 'Intrusion Attempt'
                subcategory = 'Login Attempt'

                impact = '4 - Low'
                urgency = '4 - Low'

                # find if there is issue with same title
                issue_key = slack_issues.get_issue(title, source, team)
                if issue_key != None:
                        # find if issue is correlated
                        description = slack_issues.get_issue_description_by_key(issue_key)

                        incident_is_correlated = False

                        # issue is correlated if target or threat actor is the same
                        for line in description.split('\n'):
                                if 'Threat Actor/s:' in line and threat_actor in line:
                                        incident_is_correlated = True
                                if 'Target/s:' in line and target in line:
                                        incident_is_correlated = True
                else:
                        incident_is_correlated = False

                if incident_is_correlated:
                        update = slack_issues.update_issue(issue_key, siem_id, last_seen, guardduty_id, threat_actor, target)
                        if update:
                                update_response = '*Issue updated:* https://jira.jumia.com/browse/' + issue_key
                        else:
                                update_response = '*Update failed for issue:* https://jira.jumia.com/browse/' + issue_key

                        description += update_response
                        return description

        # Port Probed use case code
        elif alert_type == 'Recon:EC2/PortProbeUnprotectedPort':

                # define threat actor, target, category, subcategory, impact and urgency
                threat_actor = log['data']['aws']['service']['action']['portProbeAction']['portProbeDetails']['remoteIpDetails']['ipAddressV4']
                target = log['data']['aws']['resource']['instanceDetails']['instanceId']
                port = log['data']['aws']['service']['action']['portProbeAction']['portProbeDetails']['localPortDetails']['port']
                instance_name = ''
                pre_analysis = 'A port scan was made on port ' + port + ' on the instance ' + target + ' (name: ' + instance_name + ').'

                category = 'Information Gathering'
                subcategory = 'Scan'

                impact = '4 - Low'
                urgency = '4 - Low'

                issue_key = slack_issues.get_issue(title, source, team)
        
        # Bind DNS (C&C) use case code
        elif alert_type == 'Backdoor:EC2/C&CActivity.B!DNS':

                # define security information
                threat_actor = log['data']['aws']['service']['action']['dnsRequestAction']['domain']
                target = log['data']['aws']['resource']['instanceDetails']['instanceId']
                instance_name = ''
                threat_list = log['data']['aws']['service']['additionalInfo']['threatListName']
                pre_analysis = 'A known Command and Control server (' + threat_actor + ', according to ' + threat_list + ') domain name was queried by EC2 instance ' + target + ' (name: ' + instance_name + ').' 
                category = 'Malware'
                subcategory = 'C&C'
                impact = '4 - Low'
                urgency = '4 - Low'

                issue_key = slack_issues.get_issue(title, source, team)
        # DGA use case code
        elif alert_type == 'Trojan:EC2/DGADomainRequest.B':
                threat_actor = log['data']['aws']['service']['action']['dnsRequestAction']['domain']
                target = log['data']['aws']['resource']['instanceDetails']['instanceId']

                category = 'Malware'
                subcategory = 'C&C'

                impact = '3 - Medium'
                urgency = '4 - Low'

                # find if there is issue with same title
                issue_key = slack_issues.get_issue(title, source, team)
                if issue_key != None:
                        # find if issue is correlated
                        description = slack_issues.get_issue_description_by_key(issue_key)

                        incident_is_correlated = False

                        # issue is correlated if target is the same
                        for line in description.split('\n'):
                                if 'Target/s:' in line and target in line:
                                        incident_is_correlated = True
                else:
                        incident_is_correlated = False

                if incident_is_correlated:
                        update = slack_issues.update_issue(issue_key, siem_id, last_seen, guardduty_id, threat_actor, target)
                        if update:
                                update_response = '*Issue updated:* https://jira.jumia.com/browse/' + issue_key
                        else:
                                update_response = '*Update failed for issue:* https://jira.jumia.com/browse/' + issue_key

                        description += update_response
                        return description
        else:
                threat_actor = ''
                target = ''
                category = 'Other'
                subcategory = 'Uncategorized'
                impact = '4 - Low'
                urgency = '4 - Low'

        description += '*Target/s:* ' + target + '\n'
        description += '*Threat Actor/s:* ' + threat_actor + '\n'
        description += '*Pre-analysis:* ' + pre_analysis
        
        issue_key = slack_issues.create_issue(title, village, team, first_seen, first_detected, category, subcategory, impact, urgency, description)

        if issue_key is None:
                update_response = '*Failed to create issue.*'
        else:
                update_response = '*Issue created:* https://jira.jumia.com/browse/' + issue_key

        description += update_response

        # EDIT SECURITY IMPACT AND URGENCY ACCORDING TO CROWDSTRIKE (Edit Issue)
        if severity == '2':
                update = {"fields": {"customfield_15012": {"value": "4 - Low"}, "customfield_15008": {"value": "4 - Low"}}}
        elif severity == '5':
                update = {"fields": {"customfield_15012": {"value": "3 - Medium"}, "customfield_15008": {"value": "3 - Medium"}}}
        elif severity == '8':
                update = {"fields": {"customfield_15012": {"value": "2 - High"}, "customfield_15008": {"value": "2 - High"}}}
        update_ticket_response = requests.put('https://jira.jumia.com/rest/api/latest/issue/' + issue_key, data=json.dumps(update), headers=headers, auth=(user, api_key))
        
        severity_jira = ''
        
        # TRANSFORM SEVERITY NUMBER INTO STRING
        if severity == '2':
            severity_jira = 'Low'
        elif severity == '5':
            severity_jira = 'Moderate'
        elif severity == '8':
            severity_jira = 'High'

        severity = severity_jira

        # INPUT A COMMENTARY TO TRIGGER THE JIRA'S PRIORITY AUTOMATION
        update = {}
        comment = 'h3. *Priority Update*\nGuardduty detected the priority of the incident as ' + severity_jira
        update['body'] = {}
        update['body'] = comment
        update_ticket_response = requests.post('https://jira.jumia.com/rest/api/latest/issue/' + issue_key + '/comment', data=json.dumps(update), headers=headers, auth=(user, api_key))
        
        return description, severity